<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Erl Assignment2: Experimental Robotics Laboratory - Assignment2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Erl Assignment2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Experimental Robotics Laboratory - Assignment2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The assignment consists in developping a software architecture to simulate an autonomous Cluedo game. The robot should explore in an arena, looking for hints which are in established locations. Reason about the hints through an ontology and find the solution of the game. The best actions that robot must perform are selected through a pddl planning system.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Software Architecture</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Robot Model</h2>
<p>IMAGE</p>
<p>The robot model is visible in the image above. It has been developped developped in the <b>sherlock_robot.gazebo</b> and <b>sherlock_robot.xacro</b> files in the urdf folder. The only constraint is reaching the height of 0.75 and 1.25 which is the height where hint are located. In order to control the arm and reach the hints the are is controlled through an ad-oc generated moveit package <b>moveit_assignment</b> foundable in the repository. The final .urdf file used is <b>sherlock_robot_moveit.urdf</b>. Moreover the robot has a derivative controller and it is equipped both of laser and camera.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Robot behavior and Rosplan</h2>
<p>STATE DIAGRAM</p>
<p>The robot can perform different actions:</p><ul>
<li>move around</li>
<li>move the gripper</li>
<li>perceive an hint</li>
<li>check the consistency of an hypothesis</li>
<li>check if an hypotesis is correct</li>
</ul>
<p>Each action represent a specific state of the robot. The sequence in which the actions are performed is the one generated as plan by the ROSplan system. The transistions between the different states is menaged by the dispatcher. In the state diagram all these state are represented, morever has been inserted another state which is the initial state of the robot, and the announce state which is a substate of the Check correct state. All the central state are connected by the reasoning which is intended for the <b>ROSplan</b> or the <b><a class="el" href="_reasoning_8py.html">Reasoning.py</a></b> which is specified above. In the <b>common</b> folder have been defined the pddl problem and domain which are respectively <b>cluedo_plan_nohint.pddl</b> and the <b>cluedo_domain_nohint.pddl</b>. The <b>plan.pddl</b> and <b>cluedo_plan_nohint.pddl</b> are generated and updated when code is running. The domain file three different types have been defined: robot, hypothesis and location. In the domain file each for is state of the robot a durative action has been defined: <b>move</b>, <b>move_gripper</b>, <b>perceive_hint</b>, <b>check_consistency</b>, <b>check_correct</b>. Moreover the action <b>new_turn</b> has been used to make the robot to visit again all the wayppoints after a turn of navigation has been completed. The durative actions are used to menage the following predicates:</p><ul>
<li><b>visited</b> , <b>non_visited</b> are used to managed the navigation between locations.</li>
<li><b>not_initial_location</b> is used to menage differently the location (0,0) and the waypoints.</li>
<li><b>at</b> is a predicate to state the actual location of the problem</li>
<li><b>move_performed</b> is a predicate used to move the robot's arm only once it has changed location</li>
<li><b>gripper_positioned</b> is a predicate used to state that the gripper has been correctly moved, and the hint can be perceived only after that. whereas <b>not_gripper_positioned</b> is used to move the robot in a new location even if the <b>perceived_hint</b> action is not correctly concluded.</li>
<li><b>perceived</b> is a predicate used to state if an hypotesis has been perceived whereas <b>consistent</b> is used to state if a consistent hypothesis has been found.</li>
<li><b>end_game</b> is grounded when a the correct hypothesis has been found. The problem file initialize the robot at the centre of the arena and all the waypoints as non visited. The only goal is that the correct hypotesis is found so the <b>end_game</b> predicate has a true value.</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
ROS nodes</h2>
<ul>
<li><b><a class="el" href="_armor_interface_8py.html">ArmorInterface.py</a></b> service server is a node used to menage with <b>armor</b>. It interacts in four possible ways: load the ontology, check the hypothesis is correct, check if there is a new consistent hypothesis and add a new hint to the ontology once it has been perceived. The empty ontology is inside <b>cluedo_ontology.owl</b> whereas an ontology is saved once the game is concluded in <b>cluedo_ontology_inference.owl</b>.</li>
<li><b><a class="el" href="_announce_hypotesis_8py.html">AnnounceHypotesis.py</a></b> is a service server used to menage the announcement behavior of the robot. Once the robot has found a new consistent hypothesis it must go at the centre of the arena and announce it. The node call directly the service to move the robot and after does the announcement simply printing the hypothesis on the shell.</li>
<li><b><a class="el" href="_reasoning_8py.html">Reasoning.py</a></b> node menage the whole simulation. It firstly ask to the <a class="el" href="_armor_interface_8py.html">ArmorInterface.py</a> service to load the ontology, then call the service to start the first phase of the game. Then since the end is not concluded it interfaces with the ROSplan system. At each ieration it firstly calls the problem loader, the plan generator, the parse plannig service and finally the dispatcher to distpatch the actions.</li>
<li><b><a class="el" href="simulation_8cpp.html">simulation.cpp</a></b> is an already implemented node which is used to position randomly the location where the hint are perceived. Moreover it generates hints randomly and publish them in the topic **/oracle_hint**, hint can be correctly perceived or malformed. Moreover it is the Oracle which responds if the hypothesis to check is correct or not.</li>
<li><b><a class="el" href="initial__phase_8cpp.html" title="Node to implement the initial phase service.">initial_phase.cpp</a></b> is a service server used to simulate the starting phase of the game. Since the height of the location where hints are perceived are is a random valuebetween 1.25 and 0.75 at each game session robot must firstly visit each location and check moving the gripper where is positioned the location. In particular the robot check only if the hint is generated when the gripper is at 0.75, if it is not generated the location is assumed at 1.25.</li>
</ul>
<p>The action called by the dispatcher are implemented as class which definition is contaioned in the <b>include/my_erl2</b> folder. In the <b>src</b> one it is possible to find the implemented actions.</p>
<ul>
<li><b><a class="el" href="move_8cpp.html">move.cpp</a></b> action is the code devoted to the motion of the robot. In order to to that it call the <b>go_to_point_action.py</b> of the <a href="https://github.com/CarmineD8/rt2_packages/tree/main/motion_plan"><b>motion_plan</b> package</a>.</li>
<li><b><a class="el" href="grippermotion_8cpp.html" title="Node to implement the check correct action.">grippermotion.cpp</a></b> is a action server devoted to the motion of the robotic arm. In order the to reach a certain location in the environment the plan and the execution of the robotic arm is directly menaged by <b>moveit</b> through the packege <b>moveit_assignment</b> present in the repository.</li>
<li><b><a class="el" href="perceivehints_8cpp.html" title="Node to implement the check correct action.">perceivehints.cpp</a></b>, <b><a class="el" href="checkconsistency_8cpp.html" title="Node to implement the check consistency action.">checkconsistency.cpp</a></b> and <b><a class="el" href="checkcorrect_8cpp.html" title="Node to implement the check correct action.">checkcorrect.cpp</a></b> are three action node that simply call <b><a class="el" href="_armor_interface_8py.html">ArmorInterface.py</a></b> respectivly to perceive a new hint, check if there is a new consistent hypothesis, check if the currecnt consistent hypothesis is correct.</li>
</ul>
<p>COMPONENT DIAGRAM</p>
<p>The Component diagram shows the simplified version of the software architecture, it is possible to see how the <b><a class="el" href="_reasoning_8py.html">Reasoning.py</a></b> node menage the whole simulation. It is the only node connected through the ROSplan, which directly menage which action to dispatch. All the action are represented by a single component called <b>rosplan_interface_action.cpp</b> for simplicity. Moreover in the diagram for the same reason it is not represented the feedback line but only the goal and the result.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Defined costume Services</h2>
<ul>
<li><b>ArmorInterface.srv</b> it is a service with as request the <b>mode</b> in which the client wants to interface with armor: 0 to load the ontology, 1 to check correct, 2 to check consistency, 3 to perceive an hint. Another request field is the <b>ID</b> of the hypothesis to check if any. The response is characterized by the <b>mode</b> and the <b>ID</b> as above, moreover is present the <b>success</b> field that it is true if the action has been correctly concluded. For example it is false when is performed a malformed hint, when there isn't new consistent hypothesis or when the checked hypothesis is uncorrect.</li>
<li><b>Announcement.srv</b> has as request the <b>who</b>, <b>what</b> and <b>where</b> fields of the hypothesis to announce. The response is a boolean <b>success</b> to state is the service has been correctly concluded.</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Parameters</h2>
<p>All the parameters defined are inside the <b>gamesession.yaml</b> file in the <b>config</b> folder.</p><ul>
<li><b>current_hypotesis</b> is used to state the current consistent hypotesis to check.</li>
<li><b>curr_ID</b> contains only the id of the current hypothesis.</li>
<li><b>ontology</b> and <b>ontology_path</b> contain the link and the path used to load the ontology.</li>
<li><b>wp1</b>, <b>wp2</b>, <b>wp3</b> and <b>wp4</b> are booleans parameters to store the actual z coordinate of the location of a specific waypoint. the param is 1 if the heigth is 0.75 otherwise when it is 1.25 the value is 0.</li>
<li><b>start</b> is the param used to menage the initial phase and make it does only once.</li>
<li><b>actual_location</b> is a parameter used to store the actual location of the robot.</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
Requirements</h1>
<p>The ROS packages needded to compile the code are:</p><ul>
<li><a href="https://github.com/EmaroLab/armor">armor</a></li>
<li><a href="https://github.com/CarmineD8/rt2_packages/tree/main/motion_plan"><b>motion_plan</b> package</a></li>
<li><a href="https://github.com/KCL-Planning/ROSPlan">ROSPlan</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
How to compile the code</h1>
<p>Clone <a href="https://github.com/AliceNardelli/erl_assignment2">erl_assignment2</a> repository. Build the workspace:</p>
<blockquote class="doxtable">
<p>catkin_make -DCATKIN_WHITELIST_PACKAGES="" </p>
</blockquote>
<p>Load the aRMOR (remember that the rosmaster must running):</p>
<blockquote class="doxtable">
<p>rosrun armor execute it.emarolab.armor.ARMORMainService </p>
</blockquote>
<p>Run the overall simulation:</p>
<blockquote class="doxtable">
<p>roslaunch moveit_assignment demo_gazebo.launch </p>
</blockquote>
<blockquote class="doxtable">
<p>roslaunch <a class="el" href="namespacemy__erl2.html">my_erl2</a> pddl_launcher.launch </p>
</blockquote>
<blockquote class="doxtable">
<p>roslaunch <a class="el" href="namespacemy__erl2.html">my_erl2</a> Cluedo_game.launch </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md9"></a>
Working hypothesis and environment</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
System's features</h2>
<ul>
<li>The overall system is characterized by a modular architecture. The aim is to distribute the code as much as possible between the different nodes. Each component has a specific role in the architecture.</li>
<li>The communication protocol more used in the overall architecture are the service and the action. This is due to the fact that the implemented nodes are mostly belonging to the <a class="el" href="namespace_reasoning.html">Reasoning</a> part of the software architecture. That means that the most of the all modules are sincronized with the others. This should cause blocking issues. The pub-sub communication protocol is mainly used between the <a class="el" href="namespace_reasoning.html">Reasoning</a> module and the Execution and Perception ones. In that case the simulator.</li>
<li>The ontology is the core of the whole game. It allows to reason about hypotesis. The hypothesis are make of hints. Hints can belong to three different classes: PERSON, PLACE and WEAPON. The perceived hints as ErlOracle message are the A-box of these concepts. The hypotesis belong to the COMPLETE class if they has at least one PERSON, one WEAPON and one PLACE, they belong also to the UNCONSISTENT class if they have more than one PERSON or PLACE or WEAPON. Consequently the consistent hypotesis are the ones that has only one entity for each hint class and they are the ones which belong to the COMPLETE class and not to the UNCOSISTENT one. The INCORRECT class has been added to the ontology and has as instances all the hypothesis already checked as not-correct. This choice has been done in order to not add hint belonging to uncorrect hypotesis and not check and announce their id more than once.</li>
<li>The oracle has been implemented from the <b><a class="el" href="simulation_8cpp.html">simulation.cpp</a></b> node which know the ID of the correct hypotesis.</li>
<li>The ROSPlan system menage the whole simulation. This firstly works as PDDL planning system which generate a plan in order to reach the goal in the optimal way. Moreover it is the interface between the PDDL file and ROS. This allows to syncronize the PDDL problem, the execution of the PDDL's durative actions and the corresponding actions in ROS. Certainly this instrument allows more optimal performances with respect to a simple FSM since they are generated by an Artificial Intelligence system.</li>
<li>The robotic arm is directly controlled by moveit that directly compute the inverse kinematic, find the optimal plan with RRT to reach a certain goal and execute it.</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
System's limitations and Possible technical Improvements</h2>
<ul>
<li>A big limitation is certainly the navigation module since it is not possible to control the yaw of the robot. This is due to the fact that in the <b>go_to_point_action.py</b> the final yaw is always zero with respect to the segment that goes from the starting location to the final one. So if the robot goes directly in two adjacent verteces of the arena the final yaw not always allows to perceive the hint. A simple solution used in that case is make robots always return in (0,0) position. A possible improvements should be modify the desired yaw in <b>go_to_point_action.py</b> or use a navigation planning system such as <b>move base</b>.</li>
<li>Another limitation is certainly the fact that after a certain number of iterations the arm does not reach the goal posistion and arm remains stopped even if <b><a class="el" href="grippermotion_8cpp.html" title="Node to implement the check correct action.">grippermotion.cpp</a></b> action conclude correctly. In order to not make impact this behavior a control is done on the perceived hints. If the same hint has been perceived twice that means that the arm doesn't move and consequently the <b>grippermotion</b> action fails. I think that a possible solution is to stop and restart moveit package after a certain number of iteration of the rosnode.</li>
<li>Certainly a big improvement can be done on the robot model. Here a simple robot has been done using primitives shapes with only the strigtly needed requirements. A possible alternative should be use an alteady implemented robot model maybe with an ad-hoc generated moveit package and navigation modules. I had preferred to put my hands directly on all this stuff.</li>
<li>Finally a limitation is the initial phase (load of the ontology and exploration of the environment ) which is not menaged through the ROSPlan. A solution is add a specific durative-action on the domain file. A predicate which is grounded only once the action is concluded and this predicate should be added as precondition of all other actions. Logically the ROS Plan will be adapted consequently. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
